rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // ============================================================
    // HELPER FUNCTIONS
    // ============================================================

    // Check if user is authenticated
    function isAuth() {
      return request.auth != null;
    }

    // Check if user is the resource owner
    function isOwner(uid) {
      return request.auth.uid == uid;
    }

    // Validate string field length
    function validStringLength(field, minLen, maxLen) {
      return field is string && field.size() >= minLen && field.size() <= maxLen;
    }

    // Validate timestamp is reasonable (not in future, not too old)
    // Updated to properly handle Firestore Timestamp objects
    function validTimestamp(ts) {
      return ts is timestamp && ts <= request.time + duration.value(60, 's');
    }

    // Validate that a number timestamp is reasonable (used for JS timestamps in milliseconds)
    function validNumberTimestamp(ts) {
      return ts is number && ts >= 0 && ts <= request.time.toMillis() + 60000;
    }

    // Validate array size
    function validArraySize(arr, maxSize) {
      return arr is list && arr.size() <= maxSize;
    }

    // Rate limiting: Check if enough time passed since last write
    // Note: This is a soft limit - can be bypassed but adds friction
    function rateLimitPassed(lastField, minSeconds) {
      return !resource.data.keys().hasAll([lastField]) ||
             request.time.toMillis() - resource.data[lastField] > minSeconds * 1000;
    }

    // ============================================================
    // DIGITAL AVATAR VALIDATION HELPERS
    // ============================================================

    // Validate skin tone is a valid ID format
    function validSkinTone(tone) {
      return tone is string && tone.size() > 0 && tone.size() < 20 &&
             tone.matches('skin_[0-9]+');
    }

    // Validate body config structure and values
    function validBodyConfig(body) {
      return body is map &&
             body.keys().hasAll(['skinTone', 'shape', 'height']) &&
             validSkinTone(body.skinTone) &&
             body.shape is string && body.shape.size() > 0 &&
             body.height is number &&
             body.height >= 0.7 &&
             body.height <= 1.3;
    }

    // Validate face config structure and values
    function validFaceConfig(face) {
      return face is map &&
             face.keys().hasAll(['shape', 'width']) &&
             face.shape is string && face.shape.size() > 0 &&
             face.width is number &&
             face.width >= 0.7 &&
             face.width <= 1.3;
    }

    // Validate eyes config structure and values
    function validEyesConfig(eyes) {
      return eyes is map &&
             eyes.keys().hasAll(['style', 'color', 'size', 'spacing', 'tilt']) &&
             eyes.style is string && eyes.style.size() > 0 &&
             eyes.color is string && eyes.color.size() > 0 &&
             eyes.size is number && eyes.size >= 0.7 && eyes.size <= 1.3 &&
             eyes.spacing is number && eyes.spacing >= 0.7 && eyes.spacing <= 1.3 &&
             eyes.tilt is number && eyes.tilt >= -15 && eyes.tilt <= 15;
    }

    // Validate hair config structure
    function validHairConfig(hair) {
      return hair is map &&
             hair.keys().hasAll(['style', 'color']) &&
             hair.style is string && hair.style.size() > 0 &&
             hair.color is string && hair.color.size() > 0;
    }

    // Validate nose config structure
    function validNoseConfig(nose) {
      return nose is map &&
             nose.keys().hasAll(['style', 'size']) &&
             nose.style is string &&
             nose.size is number && nose.size >= 0.7 && nose.size <= 1.3;
    }

    // Validate mouth config structure
    function validMouthConfig(mouth) {
      return mouth is map &&
             mouth.keys().hasAll(['style', 'size', 'lipColor', 'lipThickness']) &&
             mouth.style is string &&
             mouth.size is number && mouth.size >= 0.7 && mouth.size <= 1.3 &&
             mouth.lipColor is string &&
             mouth.lipThickness is number && mouth.lipThickness >= 0.7 && mouth.lipThickness <= 1.3;
    }

    // Main digital avatar validator
    function validDigitalAvatar(avatar) {
      return avatar is map &&
             avatar.version == 2 &&
             avatar.keys().hasAll(['body', 'face', 'eyes', 'nose', 'mouth', 'hair']) &&
             validBodyConfig(avatar.body) &&
             validFaceConfig(avatar.face) &&
             validEyesConfig(avatar.eyes) &&
             validNoseConfig(avatar.nose) &&
             validMouthConfig(avatar.mouth) &&
             validHairConfig(avatar.hair);
    }

    // ============================================================
    // USERS COLLECTION
    // ============================================================

    match /Users/{uid} {
      // Anyone authenticated can read user profiles
      allow read: if isAuth();
      
      // Users can only create/update their own profile with validation
      allow create: if isAuth() && isOwner(uid) &&
                      validStringLength(request.resource.data.username, 3, 20) &&
                      validStringLength(request.resource.data.displayName, 1, 50) &&
                      request.resource.data.usernameLower == request.resource.data.username.lower();
      
      allow update: if isAuth() && isOwner(uid) &&
                      // Prevent changing uid
                      request.resource.data.uid == resource.data.uid &&
                      // Validate updated fields if present
                      (!request.resource.data.keys().hasAll(['username']) || 
                       validStringLength(request.resource.data.username, 3, 20)) &&
                      (!request.resource.data.keys().hasAll(['displayName']) || 
                       validStringLength(request.resource.data.displayName, 1, 50)) &&
                      // Validate digital avatar if present in update
                      (!request.resource.data.keys().hasAll(['digitalAvatar']) ||
                       validDigitalAvatar(request.resource.data.digitalAvatar));
      
      allow delete: if isAuth() && isOwner(uid);

      // Inventory subcollection - cosmetic items owned by user
      match /inventory/{itemId} {
        allow read: if isAuth() && isOwner(uid);
        allow create: if isAuth() && isOwner(uid) &&
                        request.resource.data.keys().hasAll(['itemId', 'acquiredAt']) &&
                        request.resource.data.itemId == itemId;
        allow update, delete: if false; // Immutable
      }

      // Blocked users subcollection
      match /blockedUsers/{blockedUid} {
        // Read: owner can read their blocked list, OR target can check if they're blocked (for invite validation)
        allow read: if isAuth() && (isOwner(uid) || blockedUid == request.auth.uid);
        allow create: if isAuth() && isOwner(uid) &&
                        request.resource.data.blockedUserId == blockedUid &&
                        request.resource.data.blockedAt is number;
        allow update: if false; // Immutable
        allow delete: if isAuth() && isOwner(uid);
      }

      // Achievements subcollection (Phase 17 per guide)
      match /Achievements/{achievementId} {
        // User can read their own achievements
        allow read: if isAuth() && isOwner(uid);
        
        // Achievements are primarily server-written
        // Allow client writes as fallback with validation
        allow create: if isAuth() && isOwner(uid) &&
                        request.resource.data.uid == uid &&
                        request.resource.data.type is string &&
                        validTimestamp(request.resource.data.earnedAt);
        
        // Achievements are immutable once earned
        allow update, delete: if false;
      }

      // --------------------------------------------------------
      // Badges subcollection (Profile Screen Overhaul)
      // Stores earned badges with display preferences
      // --------------------------------------------------------
      match /Badges/{badgeId} {
        // User can read their own badges, others can read for profile display
        allow read: if isAuth();
        
        // Badges created via server-side function when earned
        // Client can update showcase position for display customization
        allow create: if isAuth() && isOwner(uid) &&
                        request.resource.data.keys().hasAll(['badgeId', 'earnedAt']) &&
                        request.resource.data.badgeId == badgeId &&
                        validTimestamp(request.resource.data.earnedAt);
        
        // Allow user to update their own badge display settings (showcase position, pinned)
        allow update: if isAuth() && isOwner(uid) &&
                        // Only allow updating display-related fields
                        request.resource.data.diff(resource.data).affectedKeys()
                          .hasOnly(['showcasePosition', 'pinned', 'displayOrder']);
        
        // Badges are never deleted (permanent accomplishments)
        allow delete: if false;
      }

      // TaskProgress subcollection (Phase 18 - Daily Tasks)
      match /TaskProgress/{taskId} {
        // User can only read their own task progress
        allow read: if isAuth() && isOwner(uid);
        
        // All writes must be server-side for security
        // Prevents clients from manipulating progress or claiming rewards multiple times
        allow create, update, delete: if false;
      }

      // --------------------------------------------------------
      // Settings subcollection (Inbox Overhaul)
      // Stores user preferences for inbox, notifications, etc.
      // --------------------------------------------------------
      match /settings/{settingId} {
        // User can only read their own settings
        allow read: if isAuth() && isOwner(uid);
        
        // User can create/update their own settings
        allow create, update: if isAuth() && isOwner(uid) &&
          // Validate inbox settings if this is the inbox document
          (settingId != 'inbox' || (
            // Validate notifyLevel if present (must be valid enum)
            (!request.resource.data.keys().hasAll(['defaultNotifyLevel']) ||
             request.resource.data.defaultNotifyLevel in ['all', 'mentions', 'none']) &&
            // Validate maxPinnedConversations if present (1-10)
            (!request.resource.data.keys().hasAll(['maxPinnedConversations']) ||
             (request.resource.data.maxPinnedConversations >= 1 &&
              request.resource.data.maxPinnedConversations <= 10)) &&
            // Validate recentSearches array size if present (max 10)
            (!request.resource.data.keys().hasAll(['recentSearches']) ||
             request.resource.data.recentSearches.size() <= 10) &&
            // Validate boolean fields if present
            (!request.resource.data.keys().hasAll(['showReadReceipts']) ||
             request.resource.data.showReadReceipts is bool) &&
            (!request.resource.data.keys().hasAll(['showTypingIndicators']) ||
             request.resource.data.showTypingIndicators is bool) &&
            (!request.resource.data.keys().hasAll(['showOnlineStatus']) ||
             request.resource.data.showOnlineStatus is bool) &&
            (!request.resource.data.keys().hasAll(['showLastSeen']) ||
             request.resource.data.showLastSeen is bool) &&
            (!request.resource.data.keys().hasAll(['confirmBeforeDelete']) ||
             request.resource.data.confirmBeforeDelete is bool) &&
            (!request.resource.data.keys().hasAll(['swipeActionsEnabled']) ||
             request.resource.data.swipeActionsEnabled is bool)
          ));
        
        // No delete - settings persist
        allow delete: if false;
      }

      // --------------------------------------------------------
      // GameHighScores subcollection (Phase 3 - Single-Player Games)
      // Stores per-game high score records: Users/{uid}/GameHighScores/{gameType}
      // --------------------------------------------------------
      match /GameHighScores/{gameType} {
        // User can read their own high scores
        allow read: if isAuth() && isOwner(uid);
        
        // User can create/update their own high scores with validation
        allow create, update: if isAuth() && isOwner(uid) &&
          // gameType must be valid single-player game
          gameType in ['flappy_snap', 'bounce_blitz', 'snap_2048', 'snap_snake', 'memory_snap', 'word_snap', 'reaction_tap', 'timed_tap', 'cart_course', 'tile_slide', 'brick_breaker'] &&
          // Must have required fields
          request.resource.data.gameType == gameType &&
          request.resource.data.highScore is number &&
          request.resource.data.highScore >= 0;
        
        // High scores can be deleted by owner (for reset)
        allow delete: if isAuth() && isOwner(uid);
      }

      // --------------------------------------------------------
      // GameSessions subcollection (Phase 3 - Single-Player Games)
      // Stores individual game session records: Users/{uid}/GameSessions/{sessionId}
      // --------------------------------------------------------
      match /GameSessions/{sessionId} {
        // User can read their own game sessions
        allow read: if isAuth() && isOwner(uid);
        
        // User can create their own game sessions with validation
        // TEMPORARILY SIMPLIFIED FOR DEBUGGING - remove extra validation
        allow create: if isAuth() && isOwner(uid) &&
          request.resource.data.playerId == uid;
        
        // Sessions are immutable once recorded
        allow update, delete: if false;
      }

      // --------------------------------------------------------
      // Wishlist subcollection (Shop Overhaul)
      // Stores items user wants to purchase later
      // Users/{uid}/Wishlist/{itemId}
      // --------------------------------------------------------
      match /Wishlist/{itemId} {
        // User can only read their own wishlist
        allow read: if isAuth() && isOwner(uid);
        
        // User can add items to their wishlist
        allow create: if isAuth() && isOwner(uid) &&
          request.resource.data.itemId == itemId &&
          request.resource.data.uid == uid &&
          request.resource.data.addedAt is number;
        
        // User can update wishlist items (e.g., priority, notes)
        allow update: if isAuth() && isOwner(uid) &&
          // Cannot change core fields
          request.resource.data.itemId == resource.data.itemId &&
          request.resource.data.uid == resource.data.uid;
        
        // User can remove items from wishlist
        allow delete: if isAuth() && isOwner(uid);
      }

      // --------------------------------------------------------
      // PurchaseHistory subcollection (Shop Overhaul)
      // Stores user's purchase records
      // Users/{uid}/PurchaseHistory/{purchaseId}
      // --------------------------------------------------------
      match /PurchaseHistory/{purchaseId} {
        // User can only read their own purchase history
        allow read: if isAuth() && isOwner(uid);
        
        // All purchase writes must be server-side
        // This ensures integrity with payment processing
        allow create, update, delete: if false;
      }
    }

    // ============================================================
    // USERNAMES COLLECTION (Uniqueness Index)
    // ============================================================

    match /Usernames/{username} {
      allow read: if isAuth();
      // Only create if claiming for yourself
      allow create: if isAuth() && 
                      request.resource.data.uid == request.auth.uid &&
                      username.size() >= 3 && username.size() <= 20;
      allow update, delete: if false; // Immutable - prevents username hijacking
    }

    // ============================================================
    // FRIEND REQUESTS COLLECTION
    // ============================================================

    match /FriendRequests/{requestId} {
      // Allow read for sender or recipient
      allow read: if isAuth() && 
                    (resource.data.from == request.auth.uid || 
                     resource.data.to == request.auth.uid);
      
      // Create: sender must be auth user, validate fields
      // Note: createdAt is a number (JS timestamp) not Firestore Timestamp
      // Rate limit: 1 request per 5 seconds (soft limit via client check)
      allow create: if isAuth() && 
                      request.auth.uid == request.resource.data.from &&
                      request.resource.data.from != request.resource.data.to && // Can't friend yourself
                      request.resource.data.status == 'pending' &&
                      request.resource.data.createdAt is number &&
                      validNumberTimestamp(request.resource.data.createdAt);
      
      // Update: only recipient can accept/decline
      allow update: if isAuth() && 
                      request.auth.uid == resource.data.to &&
                      resource.data.status == 'pending' && // Can only update pending requests
                      request.resource.data.status in ['accepted', 'declined'] &&
                      // Prevent tampering with other fields
                      request.resource.data.from == resource.data.from &&
                      request.resource.data.to == resource.data.to;
      
      // Delete: sender or recipient can delete
      allow delete: if isAuth() && 
                     (request.auth.uid == resource.data.from || 
                      request.auth.uid == resource.data.to);
    }

    // ============================================================
    // FRIENDS COLLECTION
    // ============================================================

    match /Friends/{friendId} {
      // Read for array-contains queries
      allow read: if isAuth() && request.auth.uid in resource.data.users;
      
      // Create: user must be in users array, validate structure
      // Note: createdAt is a number (JS timestamp) not Firestore Timestamp
      allow create: if isAuth() && 
                      request.auth.uid in request.resource.data.users &&
                      request.resource.data.users.size() == 2 &&
                      request.resource.data.streakCount == 0 &&
                      request.resource.data.createdAt is number;
      
      // Update: only members can update, protect core fields
      allow update: if isAuth() && 
                      request.auth.uid in resource.data.users &&
                      // Cannot change users array
                      request.resource.data.users == resource.data.users &&
                      // Cannot decrease streakCount arbitrarily (backend handles resets)
                      (request.resource.data.streakCount >= resource.data.streakCount ||
                       request.resource.data.streakCount == 0);
      
      // Delete: either member can unfriend
      allow delete: if isAuth() && request.auth.uid in resource.data.users;
    }

    // ============================================================
    // CHATS COLLECTION
    // ============================================================

    match /Chats/{chatId} {
      // Helper: Check if user's UID is part of the chat ID (format: uid1_uid2 sorted)
      function isUserInChatId() {
        return chatId.matches('.*' + request.auth.uid + '.*');
      }
      
      // Read: member check via chatId pattern or document membership
      allow read: if isAuth() && (
                    (resource != null && request.auth.uid in resource.data.members) ||
                    isUserInChatId()
                  );
      
      // Create: only if user is in the members array
      allow create: if isAuth() && 
                      request.auth.uid in request.resource.data.members &&
                      request.resource.data.members.size() == 2 &&
                      validTimestamp(request.resource.data.createdAt);
      
      // Update: only members can update (lastMessage, etc.)
      allow update: if isAuth() && 
                      request.auth.uid in resource.data.members &&
                      // Cannot change members
                      request.resource.data.members == resource.data.members;

      // --------------------------------------------------------
      // Messages subcollection (V2 Enhanced)
      // Supports: hiddenFor (delete-for-me), deletedForAll, edit
      // --------------------------------------------------------
      match /Messages/{messageId} {
        // Helper: Check if user is chat member
        function isChatMember() {
          return request.auth.uid in get(/databases/(default)/documents/Chats/$(chatId)).data.members;
        }
        
        // Helper: Check if user is the message sender
        function isSender() {
          return resource.data.senderId == request.auth.uid || 
                 resource.data.sender == request.auth.uid;
        }
        
        // Helper: Check if edit is within time limit (15 minutes)
        function isWithinEditWindow() {
          let createdAt = resource.data.serverReceivedAt != null 
            ? resource.data.serverReceivedAt 
            : resource.data.createdAt;
          return request.time.toMillis() - createdAt < 15 * 60 * 1000;
        }
        
        // Read: chat members only
        allow read: if isAuth() && isChatMember();
        
        // Create: sender must be auth user and chat member
        // Support both V1 (sender) and V2 (senderId) fields
        allow create: if isAuth() && 
                        isChatMember() &&
                        (request.resource.data.senderId == request.auth.uid ||
                         request.resource.data.sender == request.auth.uid) &&
                        // V1 type validation OR V2 kind validation
                        // Voice messages use type='voice' (H11)
                        (request.resource.data.type in ['text', 'image', 'scorecard', 'voice'] ||
                         request.resource.data.kind in ['text', 'media', 'voice', 'file', 'system']) &&
                        // Content length limits (V1 content or V2 text)
                        (!request.resource.data.keys().hasAll(['content']) ||
                         request.resource.data.type == 'image' ||
                         request.resource.data.type == 'voice' || 
                         validStringLength(request.resource.data.content, 0, 2000)) &&
                        (!request.resource.data.keys().hasAll(['text']) ||
                         validStringLength(request.resource.data.text, 0, 2000));
        
        // Update: V2 features - hiddenFor, deletedForAll, edit
        allow update: if isAuth() && isChatMember() && (
                        // Case 1: Delete-for-me (hiddenFor) - user can only add self, cannot remove entries
                        // Handles both: field doesn't exist OR field exists with values
                        (request.resource.data.diff(resource.data).affectedKeys().hasOnly(['hiddenFor']) &&
                         // If field exists, new array must contain all old entries
                         (!('hiddenFor' in resource.data) || 
                          request.resource.data.hiddenFor.hasAll(resource.data.hiddenFor)) &&
                         // Only the current user's uid should be added
                         ((!('hiddenFor' in resource.data) && request.resource.data.hiddenFor == [request.auth.uid]) ||
                          ('hiddenFor' in resource.data && 
                           request.resource.data.hiddenFor.removeAll(resource.data.hiddenFor) == [request.auth.uid] &&
                           request.resource.data.hiddenFor.size() > resource.data.hiddenFor.size()))) ||
                        
                        // Case 2: Delete-for-all - sender only
                        (request.resource.data.diff(resource.data).affectedKeys().hasOnly(['deletedForAll']) &&
                         isSender() &&
                         request.resource.data.deletedForAll.by == request.auth.uid) ||
                        
                        // Case 3: Edit message - sender only, within 15 min
                        (request.resource.data.diff(resource.data).affectedKeys().hasOnly(['text', 'editedAt']) &&
                         isSender() &&
                         isWithinEditWindow()) ||
                        
                        // Case 4: Legacy - mark as read (V1 compatibility)
                        (request.resource.data.sender == resource.data.sender &&
                         request.resource.data.content == resource.data.content &&
                         request.resource.data.type == resource.data.type)
                      );
        
        // Delete: members can delete (view-once snaps only)
        allow delete: if isAuth() && isChatMember();
        
        // --------------------------------------------------------
        // Reactions subcollection (V2)
        // Path: Messages/{messageId}/Reactions/{emoji}_{uid}
        // --------------------------------------------------------
        match /Reactions/{reactionId} {
          // Read: any chat member
          allow read: if isAuth() && isChatMember();
          
          // Create: user can only create their own reaction
          allow create: if isAuth() && 
                          isChatMember() &&
                          request.resource.data.uid == request.auth.uid &&
                          request.resource.data.emoji is string &&
                          request.resource.data.emoji.size() <= 10;
          
          // Delete: user can only delete their own reaction
          allow delete: if isAuth() && 
                          isChatMember() &&
                          resource.data.uid == request.auth.uid;
          
          // No updates - delete and recreate
          allow update: if false;
        }
      }

      // --------------------------------------------------------
      // Members subcollection (Public state - V2)
      // Stores: typing indicators, read receipt watermarks
      // --------------------------------------------------------
      match /Members/{uid} {
        // Read: any chat member can read all member states
        allow read: if isAuth() && 
                      request.auth.uid in get(/databases/(default)/documents/Chats/$(chatId)).data.members;
        
        // Create/Update: users can only modify their own state
        allow create, update: if isAuth() && 
                                isOwner(uid) &&
                                request.auth.uid in get(/databases/(default)/documents/Chats/$(chatId)).data.members &&
                                // Validate required field
                                request.resource.data.uid == uid;
        
        // No delete - member state persists
        allow delete: if false;
      }

      // --------------------------------------------------------
      // MembersPrivate subcollection (Private state - V2)
      // Stores: mute, archive, notification prefs, lastSeen
      // OWNER-ONLY ACCESS
      // --------------------------------------------------------
      match /MembersPrivate/{uid} {
        // Read: only the owner can read their private state
        allow read: if isAuth() && isOwner(uid);
        
        // Create/Update: owner only, with validation
        allow create, update: if isAuth() && 
                                isOwner(uid) &&
                                request.auth.uid in get(/databases/(default)/documents/Chats/$(chatId)).data.members &&
                                // Validate required field
                                request.resource.data.uid == uid &&
                                // Validate notifyLevel if present
                                (!request.resource.data.keys().hasAll(['notifyLevel']) ||
                                 request.resource.data.notifyLevel in ['all', 'mentions', 'none']);
        
        // No delete - private state persists
        allow delete: if false;
      }
    }

    // ============================================================
    // STORIES COLLECTION
    // ============================================================

    match /stories/{storyId} {
      // Read: only recipients can view
      allow read: if isAuth() && request.auth.uid in resource.data.recipientIds;
      
      // Create: author validation
      // Note: createdAt and expiresAt are numbers (JS timestamps in milliseconds)
      allow create: if isAuth() && 
                      request.auth.uid == request.resource.data.authorId &&
                      validNumberTimestamp(request.resource.data.createdAt) &&
                      // expiresAt must be in future (24h from creation typically)
                      request.resource.data.expiresAt is number &&
                      request.resource.data.expiresAt > request.time.toMillis() &&
                      // recipientIds must include author and be reasonable size
                      request.auth.uid in request.resource.data.recipientIds &&
                      validArraySize(request.resource.data.recipientIds, 1000) &&
                      // Initial viewCount must be 0
                      request.resource.data.viewCount == 0;
      
      // Update: author for content, anyone for viewCount increment
      allow update: if isAuth() && (
                      // Author can update anything
                      request.auth.uid == resource.data.authorId ||
                      // Others can only increment viewCount by 1
                      (request.auth.uid in resource.data.recipientIds &&
                       request.resource.data.diff(resource.data).affectedKeys().hasOnly(['viewCount']) &&
                       request.resource.data.viewCount == resource.data.viewCount + 1)
                    );
      
      // Delete: author only
      allow delete: if isAuth() && request.auth.uid == resource.data.authorId;

      // Views subcollection
      match /views/{userId} {
        // User can read their own view record
        allow read: if isAuth() && userId == request.auth.uid;
        
        // User can only write their own view record
        // Note: viewedAt is a number (JS timestamp in milliseconds)
        allow create: if isAuth() && 
                        userId == request.auth.uid &&
                        request.resource.data.userId == request.auth.uid &&
                        validNumberTimestamp(request.resource.data.viewedAt);
        
        allow update: if isAuth() && userId == request.auth.uid;
        allow delete: if false; // Views are permanent
      }
    }

    // ============================================================
    // REPORTS COLLECTION
    // ============================================================

    match /Reports/{reportId} {
      // Only reporter can create - add basic rate limiting via timestamp validation
      allow create: if isAuth() && 
                      request.auth.uid == request.resource.data.reporterId &&
                      request.resource.data.reporterId != request.resource.data.reportedUserId &&
                      request.resource.data.reason in ['spam', 'harassment', 'inappropriate_content', 'fake_account', 'other'] &&
                      request.resource.data.status == 'pending' &&
                      validTimestamp(request.resource.data.createdAt) &&
                      // Must have valid reportedUserId
                      request.resource.data.reportedUserId is string &&
                      request.resource.data.reportedUserId.size() > 0 &&
                      // Optional description length limit
                      (!request.resource.data.keys().hasAll(['description']) ||
                       validStringLength(request.resource.data.description, 0, 500));
      
      // No read/update/delete from client - admin only via Cloud Functions
      allow read, update, delete: if false;
    }

    // ============================================================
    // GAME SESSIONS COLLECTION
    // ============================================================

    match /GameSessions/{sessionId} {
      // Only player can read their sessions
      allow read: if isAuth() && request.auth.uid == resource.data.playerId;
      
      // Create with validation
      allow create: if isAuth() && 
                      request.auth.uid == request.resource.data.playerId &&
                      request.resource.data.score >= 0 &&
                      validTimestamp(request.resource.data.playedAt);
      
      // Sessions are immutable
      allow update, delete: if false;
    }

    // ============================================================
    // COSMETICS COLLECTION (Read-only, admin seeded)
    // ============================================================

    match /Cosmetics/{itemId} {
      allow read: if isAuth();
      allow write: if false; // Admin only via Firebase Console or Cloud Functions
    }

    // ============================================================
    // SCHEDULED MESSAGES COLLECTION (Phase 17)
    // ============================================================

    match /ScheduledMessages/{messageId} {
      // Only sender can read their scheduled messages
      allow read: if isAuth() && 
                    request.auth.uid == resource.data.senderId;
      
      // Only sender can create with valid data
      allow create: if isAuth() && 
                      request.auth.uid == request.resource.data.senderId &&
                      request.resource.data.status == 'pending' &&
                      request.resource.data.scheduledFor is timestamp &&
                      request.resource.data.scheduledFor > request.time &&
                      validStringLength(request.resource.data.content, 1, 2000) &&
                      request.resource.data.type in ['text', 'image'];
      
      // Only sender can update pending messages
      allow update: if isAuth() && 
                      request.auth.uid == resource.data.senderId &&
                      resource.data.status == 'pending' &&
                      // Cannot change senderId, recipientId, or chatId
                      request.resource.data.senderId == resource.data.senderId &&
                      request.resource.data.recipientId == resource.data.recipientId &&
                      request.resource.data.chatId == resource.data.chatId;
      
      // Only sender can delete their scheduled messages
      allow delete: if isAuth() && 
                      request.auth.uid == resource.data.senderId;
    }

    // ============================================================
    // LEADERBOARDS COLLECTION (Phase 17 - per guide)
    // Format: Leaderboards/{gameId}_{weekKey}/Entries/{uid}
    // ============================================================

    match /Leaderboards/{leaderboardId} {
      // Anyone authenticated can read leaderboard metadata
      allow read: if isAuth();
      allow write: if false; // Server-only via Cloud Functions

      match /Entries/{uid} {
        // Anyone authenticated can read leaderboard entries
        allow read: if isAuth();
        
        // Users can only write their own entry
        // Note: Prefer Cloud Function for anti-cheat; this is fallback
        allow create, update: if isAuth() && 
                                request.auth.uid == uid &&
                                request.resource.data.uid == uid &&
                                request.resource.data.score >= 0;
        
        // No deletes from client
        allow delete: if false;
      }

      // Single-player game leaderboards: Leaderboards/{gameType}/{period}/{playerId}
      match /{period}/{playerId} {
        // Anyone authenticated can read leaderboard entries
        allow read: if isAuth();
        
        // Users can only write their own entry
        allow create, update: if isAuth() && 
                                request.auth.uid == playerId &&
                                request.resource.data.playerId == playerId &&
                                request.resource.data.score >= 0 &&
                                leaderboardId in ['word_snap', 'bounce_blitz', 'tic_tac_toe', 'snap_2048', 'snap_snake', 'flappy_snap', 'memory_snap', 'reaction_tap', 'timed_tap', 'cart_course', 'tile_slide', 'brick_breaker'];
        
        // No deletes from client
        allow delete: if false;
      }
    }

    // ============================================================
    // WALLETS COLLECTION (Phase 18 - Economy)
    // Server-only writes for security
    // ============================================================

    match /Wallets/{uid} {
      // User can only read their own wallet
      allow read: if isAuth() && isOwner(uid);
      
      // All wallet writes must be server-side (Cloud Functions)
      // This prevents token manipulation by clients
      allow create, update, delete: if false;
    }

    // ============================================================
    // TRANSACTIONS COLLECTION (Phase 18 - Economy)
    // Server-only writes for security
    // ============================================================

    match /Transactions/{txId} {
      // User can only read their own transactions
      allow read: if isAuth() && 
                    resource.data.uid == request.auth.uid;
      
      // All transaction writes must be server-side
      allow create, update, delete: if false;
    }

    // ============================================================
    // TASKS COLLECTION (Phase 18 - Daily Tasks)
    // Public read for active tasks
    // ============================================================

    match /Tasks/{taskId} {
      // Anyone authenticated can read active tasks
      allow read: if isAuth();
      
      // Task creation/modification is admin-only (via console or function)
      allow create, update, delete: if false;
    }

    // ============================================================
    // PHASE 19: SHOP + LIMITED-TIME DROPS
    // ============================================================

    // SHOP CATALOG COLLECTION (Legacy - token-based shop)
    // Public read for browsing, server-only writes
    match /ShopCatalog/{itemId} {
      // Anyone authenticated can read shop items
      allow read: if isAuth();
      
      // Shop catalog management is admin-only (via console or Cloud Function)
      allow create, update, delete: if false;
    }

    // ============================================================
    // POINTS SHOP CATALOG (Shop Overhaul)
    // Token-based items purchasable with in-app currency
    // ============================================================
    match /PointsShopCatalog/{itemId} {
      // Anyone authenticated can read shop items for browsing
      allow read: if isAuth();
      
      // Catalog management is admin-only (via Firebase Console or Cloud Functions)
      allow create, update, delete: if false;
    }

    // ============================================================
    // PREMIUM PRODUCTS (Shop Overhaul)
    // Real-money items: token packs, bundles, exclusives
    // ============================================================
    match /PremiumProducts/{productId} {
      // Anyone authenticated can read premium products for browsing
      allow read: if isAuth();
      
      // Product management is admin-only (via Firebase Console or Cloud Functions)
      allow create, update, delete: if false;
    }

    // ============================================================
    // PROMOTIONS (Shop Overhaul)
    // Time-limited promotions, sales, and special offers
    // ============================================================
    match /Promotions/{promoId} {
      // Anyone authenticated can read promotions
      // Note: Active/time filtering is done client-side and server-side
      // Using resource.data checks would block list queries
      allow read: if isAuth();
      
      // Promotion management is admin-only
      allow create, update, delete: if false;
    }

    // ============================================================
    // DAILY DEALS (Shop Overhaul)
    // Rotating daily deals with limited availability
    // ============================================================
    match /DailyDeals/{dealId} {
      // Anyone authenticated can read daily deals
      // Note: Time validity filtering is done client-side and server-side
      // Using resource.data checks would block list queries
      allow read: if isAuth();
      
      // Deal management is server-only (scheduled Cloud Function)
      allow create, update, delete: if false;
    }

    // ============================================================
    // GIFTS (Shop Overhaul)
    // Sent gifts between users
    // ============================================================
    match /Gifts/{giftId} {
      // Helper: Check if user is involved in this gift
      function isGiftParticipant() {
        return resource.data.senderUid == request.auth.uid ||
               resource.data.recipientUid == request.auth.uid;
      }
      
      // Sender or recipient can read the gift
      allow read: if isAuth() && isGiftParticipant();
      
      // Gifts are created server-side after payment validation
      allow create: if false;
      
      // Recipient can update status to 'claimed' (once only)
      allow update: if isAuth() &&
                      resource.data.recipientUid == request.auth.uid &&
                      resource.data.status == 'sent' &&
                      request.resource.data.status == 'claimed' &&
                      // Cannot change other fields
                      request.resource.data.senderUid == resource.data.senderUid &&
                      request.resource.data.recipientUid == resource.data.recipientUid &&
                      request.resource.data.itemId == resource.data.itemId;
      
      // Gifts cannot be deleted
      allow delete: if false;
    }

    // PURCHASES COLLECTION
    // Owner read only, server-only writes
    match /Purchases/{purchaseId} {
      // Users can only read their own purchases
      allow read: if isAuth() && 
                    resource.data.uid == request.auth.uid;
      
      // All purchase writes must be server-side (Cloud Functions)
      // This ensures atomic operations with wallet deduction
      allow create, update, delete: if false;
    }

    // ============================================================
    // TASK PROGRESS (Phase 18 - Users/{uid}/TaskProgress/{taskId})
    // Stored as subcollection under Users
    // ============================================================

    // Note: TaskProgress is in Users/{uid}/TaskProgress/{taskId}
    // Need to add specific rules here since it's a new subcollection

    // Adding to Users collection rules...
    // (Already handled by adding subcollection match below)

    // ============================================================
    // ACHIEVEMENTS (Stored in Users/{uid}/Achievements/{achievementId})
    // Rules already covered under Users collection subcollections
    // Adding explicit match for clarity
    // ============================================================

    // Note: Achievements are stored as Users/{uid}/Achievements/{type}
    // The existing Users match handles subcollections, but we add explicit rules:

    // ============================================================
    // PHASE 20: GROUP CHAT
    // ============================================================

    // GROUPS COLLECTION
    match /Groups/{groupId} {
      // Helper: Check if user is a member via memberIds array (fast, no extra read)
      function isGroupMemberFast() {
        return request.auth.uid in resource.data.memberIds;
      }
      
      // Helper: Check if user is a member of the group via Members subcollection
      function isGroupMember() {
        return exists(/databases/$(database)/documents/Groups/$(groupId)/Members/$(request.auth.uid));
      }
      
      // Helper: Check if user is owner
      function isGroupOwner() {
        return resource.data.ownerId == request.auth.uid;
      }
      
      // Helper: Check member role
      function getMemberRole() {
        return get(/databases/$(database)/documents/Groups/$(groupId)/Members/$(request.auth.uid)).data.role;
      }
      
      // Read: Allow authenticated users to read group metadata
      allow read: if isAuth();
      
      // Create: any authenticated user can create a group
      allow create: if isAuth() &&
                      request.resource.data.ownerId == request.auth.uid &&
                      request.auth.uid in request.resource.data.memberIds &&
                      validStringLength(request.resource.data.name, 1, 50) &&
                      request.resource.data.memberCount >= 1 &&
                      request.resource.data.memberCount <= 20;
      
      // Update: Simplified - allow members to update, or non-members adding self
      allow update: if isAuth() && (
                      // Case 1: Already a member (use fast check)
                      isGroupMemberFast() ||
                      // Case 2: Accepting invite - user adding self to memberIds
                      (!(request.auth.uid in resource.data.memberIds) &&
                       request.auth.uid in request.resource.data.memberIds)
                    );
      
      // Delete: only owner can delete group
      allow delete: if isAuth() && isGroupOwner();

      // MEMBERS SUBCOLLECTION
      match /Members/{memberId} {
        // Read: any authenticated user (simplify to avoid chicken-egg issues)
        allow read: if isAuth();
        
        // Create: user can add self, or owner/admin can add others
        allow create: if isAuth() && (
                        // User creating self (owner during creation, or member when accepting invite)
                        memberId == request.auth.uid ||
                        // Owner or admin adding someone else
                        (isGroupMember() &&
                         getMemberRole() in ['owner', 'admin'])
                      );
        
        // Update: owner can change roles, or member updating their own data
        allow update: if isAuth() && (
                        get(/databases/$(database)/documents/Groups/$(groupId)).data.ownerId == request.auth.uid ||
                        memberId == request.auth.uid
                      );
        
        // Delete: owner/admin can remove, or member can leave (remove self)
        allow delete: if isAuth() && (
                        get(/databases/$(database)/documents/Groups/$(groupId)).data.ownerId == request.auth.uid ||
                        (isGroupMember() && getMemberRole() in ['owner', 'admin']) ||
                        memberId == request.auth.uid
                      );
      }

      // --------------------------------------------------------
      // MembersPrivate subcollection (Private state - V2)
      // Stores: mute, archive, notification prefs, lastSeen
      // OWNER-ONLY ACCESS - user can only read/write their own
      // --------------------------------------------------------
      match /MembersPrivate/{uid} {
        // Helper: Check membership via Group doc (for subcollection context)
        function isGroupMemberViaParent() {
          return request.auth.uid in get(/databases/$(database)/documents/Groups/$(groupId)).data.memberIds;
        }
        
        // Read: only the owner can read their private state
        allow read: if isAuth() && isOwner(uid);
        
        // Create/Update: owner only, with validation
        // Use isGroupMemberViaParent() since isGroupMemberFast() references wrong resource
        allow create, update: if isAuth() && 
                                isOwner(uid) &&
                                (isGroupMemberViaParent() || isGroupMember()) &&
                                // Validate required field
                                request.resource.data.uid == uid &&
                                // Validate notifyLevel if present
                                (!request.resource.data.keys().hasAll(['notifyLevel']) ||
                                 request.resource.data.notifyLevel in ['all', 'mentions', 'none']);
        
        // No delete - private state persists
        allow delete: if false;
      }

      // --------------------------------------------------------
      // Messages subcollection (V2 Enhanced for Groups)
      // Supports: hiddenFor (delete-for-me), deletedForAll (admin), edit
      // --------------------------------------------------------
      match /Messages/{messageId} {
        // Helper: Check if user is message sender
        function isMessageSender() {
          return resource.data.senderId == request.auth.uid || 
                 resource.data.sender == request.auth.uid;
        }
        
        // Helper: Check if user is admin or owner
        function isAdminOrOwner() {
          return isGroupMember() && getMemberRole() in ['owner', 'admin'];
        }
        
        // Helper: Check if edit is within time limit (15 minutes)
        function isWithinEditWindow() {
          let createdAt = resource.data.serverReceivedAt != null 
            ? resource.data.serverReceivedAt 
            : resource.data.createdAt;
          return request.time.toMillis() - createdAt < 15 * 60 * 1000;
        }
        
        // Helper: Check if user is group owner (for initial message during creation)
        function isGroupOwnerForMessage() {
          return getAfter(/databases/$(database)/documents/Groups/$(groupId)).data.ownerId == request.auth.uid;
        }
        
        // Helper: Check if user is being added to group in this batch (for join messages)
        function isJoiningGroupMember() {
          return request.auth.uid in getAfter(/databases/$(database)/documents/Groups/$(groupId)).data.memberIds;
        }
        
        // Helper: Check membership via parent document read (needed in subcollections)
        // NOTE: isGroupMemberFast() uses resource.data.memberIds which doesn't work in subcollections
        function isGroupMemberViaGet() {
          return request.auth.uid in get(/databases/$(database)/documents/Groups/$(groupId)).data.memberIds;
        }
        
        // Read: any group member can read messages
        allow read: if isAuth() && (isGroupMemberViaGet() || isGroupMember());
        
        // Create: sender must match auth, with content validation
        // Support both V1 (sender) and V2 (senderId) fields
        // Allow owner to create initial system message during group creation
        // Allow joining member to create system message during invite acceptance
        allow create: if isAuth() &&
                        (isGroupMemberViaGet() || isGroupMember() || isGroupOwnerForMessage() || isJoiningGroupMember()) &&
                        (request.resource.data.senderId == request.auth.uid ||
                         request.resource.data.sender == request.auth.uid) &&
                        // V1 type validation OR V2 kind validation
                        // Voice messages use type='voice' (H11)
                        (request.resource.data.type in ['text', 'image', 'system', 'voice', 'scorecard'] ||
                         request.resource.data.kind in ['text', 'media', 'voice', 'file', 'system']) &&
                        // Validate content length
                        (request.resource.data.type == 'image' ||
                         request.resource.data.type == 'system' ||
                         request.resource.data.type == 'voice' ||
                         !request.resource.data.keys().hasAll(['content']) ||
                         validStringLength(request.resource.data.content, 0, 2000)) &&
                        (!request.resource.data.keys().hasAll(['text']) ||
                         validStringLength(request.resource.data.text, 0, 2000));
        
        // Update: V2 features - hiddenFor, deletedForAll, edit
        allow update: if isAuth() && (isGroupMemberViaGet() || isGroupMember()) && (
                        // Case 1: Delete-for-me (hiddenFor) - user can only add self, cannot remove entries
                        // Handles both: field doesn't exist OR field exists with values
                        (request.resource.data.diff(resource.data).affectedKeys().hasOnly(['hiddenFor']) &&
                         // If field exists, new array must contain all old entries
                         (!('hiddenFor' in resource.data) || 
                          request.resource.data.hiddenFor.hasAll(resource.data.hiddenFor)) &&
                         // Only the current user's uid should be added
                         ((!('hiddenFor' in resource.data) && request.resource.data.hiddenFor == [request.auth.uid]) ||
                          ('hiddenFor' in resource.data && 
                           request.resource.data.hiddenFor.removeAll(resource.data.hiddenFor) == [request.auth.uid] &&
                           request.resource.data.hiddenFor.size() > resource.data.hiddenFor.size()))) ||
                        
                        // Case 2: Delete-for-all - sender OR admin/owner
                        (request.resource.data.diff(resource.data).affectedKeys().hasOnly(['deletedForAll']) &&
                         (isMessageSender() || isAdminOrOwner()) &&
                         request.resource.data.deletedForAll.by == request.auth.uid) ||
                        
                        // Case 3: Edit message - sender only, within 15 min
                        (request.resource.data.diff(resource.data).affectedKeys().hasOnly(['text', 'editedAt']) &&
                         isMessageSender() &&
                         isWithinEditWindow())
                      );
        
        // Delete: Not allowed (use deletedForAll or hiddenFor instead)
        allow delete: if false;
        
        // --------------------------------------------------------
        // Reactions subcollection (V2)
        // Path: Messages/{messageId}/Reactions/{emoji}_{uid}
        // --------------------------------------------------------
        match /Reactions/{reactionId} {
          // Read: any group member
          allow read: if isAuth() && (isGroupMemberFast() || isGroupMember());
          
          // Create: user can only create their own reaction
          allow create: if isAuth() && 
                          (isGroupMemberFast() || isGroupMember()) &&
                          request.resource.data.uid == request.auth.uid &&
                          request.resource.data.emoji is string &&
                          request.resource.data.emoji.size() <= 10;
          
          // Delete: user can only delete their own reaction
          allow delete: if isAuth() && 
                          (isGroupMemberFast() || isGroupMember()) &&
                          resource.data.uid == request.auth.uid;
          
          // No updates - delete and recreate
          allow update: if false;
        }
      }
    }

    // GROUP INVITES COLLECTION
    match /GroupInvites/{inviteId} {
      // Read: Any authenticated user can read
      allow read: if isAuth();
      
      // Create: sender must be authenticated, validate all fields
      // Added timestamp validation and size limits
      allow create: if isAuth() &&
                      request.resource.data.fromUid == request.auth.uid &&
                      request.resource.data.status == 'pending' &&
                      request.resource.data.fromUid != request.resource.data.toUid &&
                      request.resource.data.expiresAt is number &&
                      request.resource.data.createdAt is number &&
                      validNumberTimestamp(request.resource.data.createdAt) &&
                      // Ensure target user ID is valid
                      request.resource.data.toUid is string &&
                      request.resource.data.toUid.size() > 0 &&
                      // Ensure group ID is valid
                      request.resource.data.groupId is string &&
                      request.resource.data.groupId.size() > 0;
      
      // Update: only recipient can accept/decline
      allow update: if isAuth() &&
                      resource.data.toUid == request.auth.uid &&
                      resource.data.status == 'pending' &&
                      request.resource.data.status in ['accepted', 'declined'];
      
      // Delete: sender or recipient can delete
      allow delete: if isAuth() &&
                     (resource.data.fromUid == request.auth.uid ||
                      resource.data.toUid == request.auth.uid);
    }

    // ============================================================
    // PHASE 21: TRUST & SAFETY V1.5
    // Bans, Strikes, Admin Moderation
    // ============================================================

    // BANS COLLECTION
    // User can read their own ban; writes are admin-only (via Cloud Functions)
    match /Bans/{uid} {
      // User can read their own ban status
      allow read: if isAuth() && isOwner(uid);
      
      // All writes must be admin-only via Cloud Functions
      // Admin check: request.auth.token.admin == true
      allow create, update, delete: if false;
    }

    // USER STRIKES COLLECTION
    // User can read their own strikes; writes are admin-only
    match /UserStrikes/{uid} {
      // User can read their own strike record
      allow read: if isAuth() && isOwner(uid);
      
      // All writes must be admin-only via Cloud Functions
      allow create, update, delete: if false;
    }

    // USER WARNINGS COLLECTION
    // User can read their own warnings and update status to read/acknowledged
    match /UserWarnings/{warningId} {
      // User can read their own warnings
      allow read: if isAuth() && resource.data.uid == request.auth.uid;
      
      // User can update only status-related fields (mark as read/acknowledged)
      allow update: if isAuth() && 
                      resource.data.uid == request.auth.uid &&
                      // Only allow updating status-related fields
                      request.resource.data.status in ['read', 'acknowledged'] &&
                      // Prevent tampering with other fields
                      request.resource.data.uid == resource.data.uid &&
                      request.resource.data.reason == resource.data.reason &&
                      request.resource.data.issuedBy == resource.data.issuedBy &&
                      request.resource.data.issuedAt == resource.data.issuedAt;
      
      // Create/delete: admin-only via Cloud Functions
      allow create, delete: if false;
    }

    // REPORTS COLLECTION
    // Enhanced rules for admin access
    match /Reports/{reportId} {
      // Helper: Check if user is admin
      function isAdmin() {
        return request.auth.token.admin == true;
      }
      
      // Read: reporter can read their own reports, or admin can read all
      allow read: if isAuth() && (
                      resource.data.reporterId == request.auth.uid ||
                      isAdmin()
                    );
      
      // Create: any authenticated user can create a report
      allow create: if isAuth() &&
                      request.resource.data.reporterId == request.auth.uid &&
                      request.resource.data.reporterId != request.resource.data.reportedUserId &&
                      request.resource.data.status == 'pending' &&
                      request.resource.data.reason in ['spam', 'harassment', 'inappropriate_content', 'fake_account', 'other'] &&
                      request.resource.data.createdAt is number;
      
      // Update: only admins can update reports (resolve, dismiss, etc.)
      allow update: if isAuth() && isAdmin();
      
      // Delete: admins only
      allow delete: if isAuth() && isAdmin();
    }

    // EVENTS COLLECTION (Domain Events for Migration Prep)
    // Server-only writes for future sync/migration
    match /Events/{eventId} {
      // Events are server-write only
      // Could allow admin read for debugging
      allow read: if isAuth() && request.auth.token.admin == true;
      allow create, update, delete: if false;
    }

    // ============================================================
    // PHASE 22: GAMES EXPANSION - TURN-BASED & REAL-TIME GAMES
    // ============================================================

    // TURN-BASED GAMES COLLECTION
    // Stores chess, checkers, tic-tac-toe, crazy eights, 8-ball pool
    match /TurnBasedGames/{gameId} {
      // Helper: Check if user is a player in this game
      function isGamePlayer() {
        return request.auth.uid in resource.data.playerIds;
      }
      
      // Helper: Check if user is the current turn holder
      function isCurrentTurn() {
        return resource.data.currentTurn == request.auth.uid;
      }
      
      // Helper: Check if game is in active status
      function isGameActive() {
        return resource.data.status == 'active';
      }

      // Helper: Check if game allows spectators
      function allowsSpectators() {
        return resource.data.get('config', {}).get('allowSpectators', false) == true;
      }
      
      // Read: players can read their games, spectators can read if allowed
      allow read: if isAuth() && (isGamePlayer() || allowsSpectators());
      
      // Create: TEMPORARILY SIMPLIFIED FOR DEBUGGING
      // Any authenticated user can create a game (will restore validation later)
      allow create: if isAuth();
      
      // Update: Players can update their games
      // - Make moves when it's their turn
      // - End game, resign, offer draw (any player)
      // Complex validation is done server-side
      allow update: if isAuth() && 
                      isGamePlayer() && 
                      (
                        // Current turn player can make moves
                        isCurrentTurn() || 
                        // Game already ended
                        resource.data.status in ['completed', 'abandoned'] ||
                        // Any player can end/resign (changing status to completed/abandoned)
                        request.resource.data.status in ['completed', 'abandoned'] ||
                        // Any player can offer/respond to draw
                        request.resource.data.keys().hasAny(['drawOfferedBy', 'drawAccepted'])
                      ) &&
                      // Cannot change playerIds
                      request.resource.data.playerIds == resource.data.playerIds &&
                      // Cannot change gameType
                      request.resource.data.gameType == resource.data.gameType;
      
      // Delete: Not allowed (games are preserved for history)
      allow delete: if false;
      
      // MOVES SUBCOLLECTION (Game History)
      match /Moves/{moveId} {
        // Read: any game player or spectator (if allowed)
        allow read: if isAuth() && (
                      request.auth.uid in get(/databases/$(database)/documents/TurnBasedGames/$(gameId)).data.playerIds ||
                      get(/databases/$(database)/documents/TurnBasedGames/$(gameId)).data.get('config', {}).get('allowSpectators', false) == true
                    );
        
        // Create: current turn player only, validated server-side
        allow create: if isAuth() &&
                        get(/databases/$(database)/documents/TurnBasedGames/$(gameId)).data.currentTurn == request.auth.uid &&
                        request.resource.data.playerId == request.auth.uid &&
                        request.resource.data.createdAt is timestamp;
        
        // Moves are immutable
        allow update, delete: if false;
      }

      // SPECTATORS SUBCOLLECTION
      // Tracks who is watching a game in real-time
      match /spectators/{spectatorId} {
        // Read: anyone authenticated can see spectators (for spectator count display)
        allow read: if isAuth();
        
        // Create: users can join as spectators if game allows it
        allow create: if isAuth() &&
                        get(/databases/$(database)/documents/TurnBasedGames/$(gameId)).data.get('config', {}).get('allowSpectators', false) == true &&
                        request.resource.data.userId == request.auth.uid;
        
        // Update: users can update their own spectator entry
        allow update: if isAuth() && resource.data.userId == request.auth.uid;
        
        // Delete: users can stop spectating (leave)
        allow delete: if isAuth() && resource.data.userId == request.auth.uid;
      }
    }

    // ============================================================
    // GAME HISTORY COLLECTION (Phase 1: Game System Overhaul)
    // Stores completed game records for statistics and history
    // Created by Cloud Functions when games complete
    // ============================================================
    match /GameHistory/{historyId} {
      // Helper: Check if user was a player in this game
      function wasPlayerInGame() {
        return request.auth.uid in resource.data.playerIds;
      }
      
      // Read: Users can read their own game history
      // Supports queries with playerIds array-contains filter
      allow read: if isAuth() && wasPlayerInGame();
      
      // Create: Only Cloud Functions can create history records
      // This ensures data integrity - clients cannot fabricate game results
      allow create: if false;
      
      // Update: History records are immutable
      // Any corrections must go through administrative processes
      allow update: if false;
      
      // Delete: History records cannot be deleted
      // Preserves complete game history for stats and analytics
      allow delete: if false;
    }

    // ============================================================
    // LEADERBOARD STATS COLLECTION (Phase 8: Leaderboards)
    // Stores aggregated player stats for leaderboard rankings
    // Created/updated by Cloud Functions when games complete
    // ============================================================
    match /LeaderboardStats/{statsId} {
      // Read: Anyone authenticated can read leaderboard stats
      // This enables global leaderboard queries
      allow read: if isAuth();
      
      // Create/Update: Only Cloud Functions can write stats
      // This ensures data integrity - clients cannot manipulate rankings
      allow create: if false;
      allow update: if false;
      
      // Delete: Stats records cannot be deleted
      // Preserves leaderboard integrity
      allow delete: if false;
    }

    // GAME INVITES COLLECTION (UNIVERSAL INVITES)
    // Supports both legacy person-specific and new universal invites
    match /GameInvites/{inviteId} {

      // Helper: Check if user can access this invite (for document-level access)
      function canAccessInvite() {
        let data = resource.data;
        // Sender always has access
        return data.senderId == request.auth.uid ||
          // Specific recipient has access (legacy DM behavior)
          (data.get('targetType', 'specific') == 'specific' &&
           data.get('recipientId', '') == request.auth.uid) ||
          // Universal: check eligibleUserIds array
          (data.get('targetType', 'specific') == 'universal' &&
           request.auth.uid in data.get('eligibleUserIds', [])) ||
          // Legacy support: check recipientId for old invites
          data.get('recipientId', '') == request.auth.uid ||
          // QUERY SUPPORT: Allow if user is in eligibleUserIds (simplifies queries)
          request.auth.uid in data.get('eligibleUserIds', []);
      }

      // Helper: Check if invite is full
      function isFull() {
        return resource.data.get('claimedSlots', []).size() >=
               resource.data.get('requiredPlayers', 2);
      }

      // Read: users who can access the invite
      // Supports queries with eligibleUserIds array-contains filter
      allow read: if isAuth() && canAccessInvite();

      // Create: authenticated users can create invites
      allow create: if isAuth() &&
        request.resource.data.senderId == request.auth.uid &&
        request.resource.data.status == 'pending' &&
        // Must have at least sender in claimedSlots (for universal) OR be legacy invite
        (request.resource.data.get('claimedSlots', []).size() >= 1 ||
         request.resource.data.get('recipientId', '') != '');

      // Update: Various actions allowed
      allow update: if isAuth() && (
        // CLAIM SLOT: Eligible user joining
        (canAccessInvite() &&
         resource.data.status in ['pending', 'filling'] &&
         request.resource.data.get('claimedSlots', []).size() >
           resource.data.get('claimedSlots', []).size()) ||

        // UNCLAIM SLOT: User leaving (not host) - allowed in pending, filling, or ready
        (canAccessInvite() &&
         resource.data.status in ['pending', 'filling', 'ready'] &&
         resource.data.get('claimedSlots', [])[0].playerId != request.auth.uid &&
         request.resource.data.get('claimedSlots', []).size() <
           resource.data.get('claimedSlots', []).size()) ||

        // STATUS CHANGE: Filling when players join
        (canAccessInvite() &&
         resource.data.status == 'pending' &&
         request.resource.data.status == 'filling') ||

        // STATUS CHANGE: Ready when full
        (canAccessInvite() &&
         resource.data.status in ['pending', 'filling'] &&
         request.resource.data.status == 'ready') ||

        // STATUS CHANGE: Back to filling/pending when players leave from ready
        (canAccessInvite() &&
         resource.data.status == 'ready' &&
         request.resource.data.status in ['pending', 'filling']) ||

        // START GAME: Host starting game (changes to active)
        (resource.data.senderId == request.auth.uid &&
         resource.data.status in ['pending', 'filling', 'ready'] &&
         request.resource.data.status == 'active') ||

        // DECLINE: Specific recipient declining
        (resource.data.get('targetType', 'specific') == 'specific' &&
         resource.data.get('recipientId', '') == request.auth.uid &&
         resource.data.status == 'pending' &&
         request.resource.data.status == 'declined') ||

        // CANCEL: Sender cancelling - allowed in pending, filling, or ready
        (resource.data.senderId == request.auth.uid &&
         resource.data.status in ['pending', 'filling', 'ready'] &&
         request.resource.data.status == 'cancelled') ||

        // JOIN AS SPECTATOR
        (canAccessInvite() &&
         resource.data.get('spectatingEnabled', true) == true &&
         resource.data.status in ['ready', 'active'] &&
         request.resource.data.get('spectators', []).size() >
           resource.data.get('spectators', []).size()) ||

        // LEAVE AS SPECTATOR
        (canAccessInvite() &&
         request.resource.data.get('spectators', []).size() <
           resource.data.get('spectators', []).size()) ||

        // LEGACY: Old accept/decline behavior
        (resource.data.get('recipientId', '') == request.auth.uid &&
         resource.data.status == 'pending' &&
         request.resource.data.status in ['accepted', 'declined']) ||

        // LEGACY: Old cancel behavior
        (resource.data.senderId == request.auth.uid &&
         resource.data.status == 'pending' &&
         request.resource.data.status == 'cancelled') ||

        // COMPLETE: Participants can mark active invite as completed (cleanup)
        // This allows client-side cleanup when game has finished
        (canAccessInvite() &&
         resource.data.status == 'active' &&
         request.resource.data.status == 'completed')
      );

      // Delete: sender can delete
      allow delete: if isAuth() && resource.data.senderId == request.auth.uid;
    }

    // =====================================================
    // SPECTATOR INVITES COLLECTION (SINGLE-PLAYER GAMES)
    // Allows inviting others to watch single-player games
    // =====================================================
    match /SpectatorInvites/{inviteId} {
      
      // Helper: Check if user can access this invite (for document reads)
      function canAccessSpectatorInvite() {
        let data = resource.data;
        return data.hostId == request.auth.uid ||
               request.auth.uid in data.eligibleUserIds;
      }

      // Read: host and eligible spectators can read
      // For queries: use array-contains on eligibleUserIds to satisfy security
      // For document reads: check host or eligibleUserIds membership
      allow read: if isAuth() && (
        resource.data.hostId == request.auth.uid ||
        request.auth.uid in resource.data.eligibleUserIds
      );

      // Create: authenticated users can create spectator invites
      allow create: if isAuth() &&
        request.resource.data.hostId == request.auth.uid &&
        request.resource.data.status == 'pending' &&
        request.resource.data.spectators.size() == 0;

      // Update: Various actions allowed
      allow update: if isAuth() && (
        // HOST: Can update status (start, end, cancel)
        (resource.data.hostId == request.auth.uid &&
         request.resource.data.status in ['active', 'completed', 'cancelled']) ||

        // HOST: Can set liveSessionId
        (resource.data.hostId == request.auth.uid &&
         resource.data.status == 'pending' &&
         request.resource.data.liveSessionId != null) ||

        // JOIN AS SPECTATOR: Eligible user joining
        ((resource.data.hostId == request.auth.uid || request.auth.uid in resource.data.eligibleUserIds) &&
         resource.data.status in ['pending', 'active'] &&
         request.resource.data.spectators.size() > resource.data.spectators.size()) ||

        // LEAVE AS SPECTATOR
        ((resource.data.hostId == request.auth.uid || request.auth.uid in resource.data.eligibleUserIds) &&
         request.resource.data.spectators.size() < resource.data.spectators.size())
      );

      // Delete: host can delete
      allow delete: if isAuth() && resource.data.hostId == request.auth.uid;
    }

    // =====================================================
    // LIVE SPECTATOR SESSIONS COLLECTION
    // Real-time game state for spectators to watch
    // =====================================================
    match /LiveSpectatorSessions/{sessionId} {
      
      // Helper: Check if user can access this session
      function canAccessLiveSession() {
        let data = resource.data;
        return data.hostId == request.auth.uid ||
               request.auth.uid in data.get('invitedUserIds', []) ||
               data.get('spectators', []).size() > 0;
      }

      // Read: host and invited users can read
      allow read: if isAuth() && (
        resource.data.hostId == request.auth.uid ||
        request.auth.uid in resource.data.get('invitedUserIds', [])
      );

      // Create: authenticated users can create sessions for themselves
      allow create: if isAuth() &&
        request.resource.data.hostId == request.auth.uid &&
        request.resource.data.status in ['waiting', 'active'];

      // Update: host can update game state, spectators can join/leave
      allow update: if isAuth() && (
        // HOST: Can update game state, status, score
        resource.data.hostId == request.auth.uid ||

        // JOIN AS SPECTATOR
        (request.auth.uid in resource.data.get('invitedUserIds', []) &&
         resource.data.status in ['waiting', 'active'] &&
         request.resource.data.get('spectators', []).size() >
           resource.data.get('spectators', []).size()) ||

        // LEAVE AS SPECTATOR
        (request.resource.data.get('spectators', []).size() <
           resource.data.get('spectators', []).size())
      );

      // Delete: host can delete
      allow delete: if isAuth() && resource.data.hostId == request.auth.uid;
    }

    // MATCHMAKING QUEUE COLLECTION
    // Handles automatic matchmaking for games
    match /MatchmakingQueue/{entryId} {
      // Read: users can read their own queue entries
      allow read: if isAuth() && resource.data.playerId == request.auth.uid;
      
      // Create: user can join queue
      allow create: if isAuth() &&
                      request.resource.data.playerId == request.auth.uid &&
                      request.resource.data.status == 'searching' &&
                      request.resource.data.gameType in ['chess', 'checkers', 'tic_tac_toe', 'crazy_eights', '8ball_pool'] &&
                      request.resource.data.createdAt is timestamp &&
                      request.resource.data.rating is number;
      
      // Update: user can update own entry (rating range expansion), server updates for match
      allow update: if isAuth() && (
                      // User updating their own searching entry
                      (resource.data.playerId == request.auth.uid &&
                       resource.data.status == 'searching') ||
                      // Allow server/transaction update for matching
                      (resource.data.playerId == request.auth.uid ||
                       request.resource.data.matchedWith == request.auth.uid)
                    );
      
      // Delete: user can leave queue
      allow delete: if isAuth() && resource.data.playerId == request.auth.uid;
    }

    // PLAYER RATINGS COLLECTION
    // Stores ELO/rating data for competitive games
    match /PlayerRatings/{ratingId} {
      // Read: anyone can read ratings (for matchmaking/display)
      allow read: if isAuth();
      
      // Create: users can create their own ratings doc
      allow create: if isAuth() && ratingId.matches(request.auth.uid + '_.*');
      
      // Update: Server-side only to prevent rating manipulation
      allow update: if false;
      
      // Delete: not allowed
      allow delete: if false;
    }

    // MATCH SPECTATORS COLLECTION
    // Tracks who is watching a game
    match /MatchSpectators/{spectatorId} {
      // Read: authenticated users can see spectators
      allow read: if isAuth();
      
      // Create: users can spectate games
      allow create: if isAuth() &&
                      request.resource.data.userId == request.auth.uid;
      
      // Update: users can update their own spectator entry
      allow update: if isAuth() && resource.data.userId == request.auth.uid;
      
      // Delete: users can stop spectating
      allow delete: if isAuth() && resource.data.userId == request.auth.uid;
    }

    // MATCH CHAT COLLECTION  
    // In-game chat messages during matches
    match /MatchChat/{messageId} {
      // Read: participants can read messages
      allow read: if isAuth();
      
      // Create: participants can send messages
      allow create: if isAuth() &&
                      request.resource.data.senderId == request.auth.uid &&
                      request.resource.data.text is string &&
                      request.resource.data.text.size() > 0 &&
                      request.resource.data.text.size() <= 500 &&
                      request.resource.data.createdAt is timestamp;
      
      // Messages are immutable
      allow update, delete: if false;
    }

    // PLAYER GAME STATS COLLECTION
    // Stores per-player statistics for all games
    match /PlayerGameStats/{playerId} {
      // Read: anyone can read stats (for leaderboards)
      allow read: if isAuth();
      
      // Create: users can create their own stats doc
      allow create: if isAuth() && isOwner(playerId);
      
      // Update: users can update their own stats
      // Stats track game results and ratings
      allow update: if isAuth() && isOwner(playerId) &&
                      // Ensure playerId cannot be changed
                      request.resource.data.playerId == resource.data.playerId &&
                      // Ensure total games can only increase
                      request.resource.data.totalGames >= resource.data.totalGames;
      
      // Delete: not allowed
      allow delete: if false;
    }

    // PLAYER ACHIEVEMENTS COLLECTION
    // Stores achievement progress per player
    match /PlayerAchievements/{playerId} {
      // Read: user can read own achievements, others for profile display
      allow read: if isAuth();
      
      // Create: user can create own achievements doc
      allow create: if isAuth() && isOwner(playerId);
      
      // Update: user can update own achievements
      // Progress is validated by thresholds, and values can only increase
      allow update: if isAuth() && isOwner(playerId) &&
                      // Ensure playerId cannot be changed
                      request.resource.data.playerId == resource.data.playerId &&
                      // Ensure totalUnlocked can only increase
                      request.resource.data.totalUnlocked >= resource.data.totalUnlocked;
      
      // Delete: not allowed
      allow delete: if false;
    }

    // SINGLE-PLAYER SESSIONS COLLECTION
    // Stores individual game session results
    match /SinglePlayerSessions/{sessionId} {
      // Read: user can read own sessions
      allow read: if isAuth() && resource.data.playerId == request.auth.uid;
      
      // Create: user can record own session
      allow create: if isAuth() &&
                      request.resource.data.playerId == request.auth.uid &&
                      request.resource.data.gameType in ['flappy_dunk', 'bounce_master', 'color_match_blitz', 'daily_puzzle', 'bounce_blitz', 'snap_2048', 'snap_snake', 'word_snap'] &&
                      request.resource.data.finalScore is number &&
                      request.resource.data.finalScore >= 0 &&
                      request.resource.data.startedAt is number &&
                      request.resource.data.endedAt is number;
      
      // Sessions are immutable once recorded
      allow update, delete: if false;
    }

    // DAILY LEADERBOARDS COLLECTION
    // Aggregated daily high scores
    match /DailyLeaderboards/{leaderboardId} {
      // Read: anyone authenticated can read leaderboards
      allow read: if isAuth();
      
      // Write: Server-side only via Cloud Functions
      allow create, update, delete: if false;
    }

    // ============================================================
    // CALL SYSTEM
    // ============================================================

    // CALLS COLLECTION
    // Stores active and completed call documents
    match /Calls/{callId} {
      // Helper: Check if user is a participant in the call
      function isParticipant() {
        return request.auth.uid in resource.data.participants;
      }
      
      function isParticipantInNew() {
        return request.auth.uid in request.resource.data.participants;
      }
      
      // Helper: Check if user is the caller
      function isCaller() {
        return request.auth.uid == resource.data.callerId;
      }
      
      function isCallerInNew() {
        return request.auth.uid == request.resource.data.callerId;
      }
      
      // Read: only participants can read call documents
      allow read: if isAuth() && isParticipant();
      
      // Create: authenticated users can create calls where they are the caller
      allow create: if isAuth() && 
                      isCallerInNew() &&
                      isParticipantInNew() &&
                      request.resource.data.status == 'ringing' &&
                      request.resource.data.type in ['audio', 'video'] &&
                      request.resource.data.scope in ['dm', 'group'];
      
      // Update: participants can update call (answer, end, update media state)
      allow update: if isAuth() && isParticipant() &&
                      // Cannot change immutable fields
                      request.resource.data.callerId == resource.data.callerId &&
                      request.resource.data.conversationId == resource.data.conversationId &&
                      request.resource.data.type == resource.data.type &&
                      request.resource.data.scope == resource.data.scope &&
                      request.resource.data.createdAt == resource.data.createdAt;
      
      // Delete: never delete calls, use status field
      allow delete: if false;
    }

    // CALL HISTORY SUBCOLLECTION
    // Stores denormalized call history per user for fast queries
    match /Users/{userId}/CallHistory/{callId} {
      // Read: user can only read their own call history
      allow read: if isAuth() && isOwner(userId);
      
      // Write: Cloud Functions only (created when call ends)
      allow create, update, delete: if false;
    }

    // CALL SIGNALING COLLECTION
    // WebRTC signaling messages (offers, answers, ICE candidates)
    match /CallSignaling/{callId}/Signals/{signalId} {
      // Read: authenticated users can read signals addressed to them
      allow read: if isAuth() && resource.data.to == request.auth.uid;
      
      // Create: authenticated users can create signals from themselves
      allow create: if isAuth() && 
                      request.resource.data.from == request.auth.uid &&
                      request.resource.data.type in ['offer', 'answer', 'ice-candidate', 'bye'] &&
                      request.resource.data.callId == callId;
      
      // Update: not allowed (signals are immutable)
      allow update: if false;
      
      // Delete: recipient can delete after processing
      allow delete: if isAuth() && resource.data.to == request.auth.uid;
    }

    // ============================================================
    // CATCH-ALL: Deny everything else
    // ============================================================

    match /{document=**} {
      allow read, write: if false;
    }
  }
}
