rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // ============================================================
    // HELPER FUNCTIONS
    // ============================================================

    // Check if user is authenticated
    function isAuth() {
      return request.auth != null;
    }

    // Check if user is the resource owner
    function isOwner(uid) {
      return request.auth.uid == uid;
    }

    // Validate string field length
    function validStringLength(field, minLen, maxLen) {
      return field is string && field.size() >= minLen && field.size() <= maxLen;
    }

    // Validate timestamp is reasonable (not in future, not too old)
    function validTimestamp(ts) {
      return ts is number && ts > 0 && ts <= request.time.toMillis() + 60000;
    }

    // Validate array size
    function validArraySize(arr, maxSize) {
      return arr is list && arr.size() <= maxSize;
    }

    // Rate limiting: Check if enough time passed since last write
    // Note: This is a soft limit - can be bypassed but adds friction
    function rateLimitPassed(lastField, minSeconds) {
      return !resource.data.keys().hasAll([lastField]) ||
             request.time.toMillis() - resource.data[lastField] > minSeconds * 1000;
    }

    // ============================================================
    // USERS COLLECTION
    // ============================================================

    match /Users/{uid} {
      // Anyone authenticated can read user profiles
      allow read: if isAuth();
      
      // Users can only create/update their own profile with validation
      allow create: if isAuth() && isOwner(uid) &&
                      validStringLength(request.resource.data.username, 3, 20) &&
                      validStringLength(request.resource.data.displayName, 1, 50) &&
                      request.resource.data.usernameLower == request.resource.data.username.lower();
      
      allow update: if isAuth() && isOwner(uid) &&
                      // Prevent changing uid
                      request.resource.data.uid == resource.data.uid &&
                      // Validate updated fields if present
                      (!request.resource.data.keys().hasAll(['username']) || 
                       validStringLength(request.resource.data.username, 3, 20)) &&
                      (!request.resource.data.keys().hasAll(['displayName']) || 
                       validStringLength(request.resource.data.displayName, 1, 50));
      
      allow delete: if isAuth() && isOwner(uid);

      // Inventory subcollection - cosmetic items owned by user
      match /inventory/{itemId} {
        allow read: if isAuth() && isOwner(uid);
        allow create: if isAuth() && isOwner(uid) &&
                        request.resource.data.keys().hasAll(['itemId', 'acquiredAt']) &&
                        request.resource.data.itemId == itemId;
        allow update, delete: if false; // Immutable
      }

      // Blocked users subcollection
      match /blockedUsers/{blockedUid} {
        allow read: if isAuth() && isOwner(uid);
        allow create: if isAuth() && isOwner(uid) &&
                        request.resource.data.blockedUserId == blockedUid &&
                        validTimestamp(request.resource.data.blockedAt);
        allow update: if false; // Immutable
        allow delete: if isAuth() && isOwner(uid);
      }
    }

    // ============================================================
    // USERNAMES COLLECTION (Uniqueness Index)
    // ============================================================

    match /Usernames/{username} {
      allow read: if isAuth();
      // Only create if claiming for yourself
      allow create: if isAuth() && 
                      request.resource.data.uid == request.auth.uid &&
                      username.size() >= 3 && username.size() <= 20;
      allow update, delete: if false; // Immutable - prevents username hijacking
    }

    // ============================================================
    // FRIEND REQUESTS COLLECTION
    // ============================================================

    match /FriendRequests/{requestId} {
      // Allow read for sender or recipient
      allow read: if isAuth() && 
                    (resource.data.from == request.auth.uid || 
                     resource.data.to == request.auth.uid);
      
      // Create: sender must be auth user, validate fields
      allow create: if isAuth() && 
                      request.auth.uid == request.resource.data.from &&
                      request.resource.data.from != request.resource.data.to && // Can't friend yourself
                      request.resource.data.status == 'pending' &&
                      validTimestamp(request.resource.data.createdAt);
      
      // Update: only recipient can accept/decline
      allow update: if isAuth() && 
                      request.auth.uid == resource.data.to &&
                      resource.data.status == 'pending' && // Can only update pending requests
                      request.resource.data.status in ['accepted', 'declined'] &&
                      // Prevent tampering with other fields
                      request.resource.data.from == resource.data.from &&
                      request.resource.data.to == resource.data.to;
      
      // Delete: sender or recipient can delete
      allow delete: if isAuth() && 
                     (request.auth.uid == resource.data.from || 
                      request.auth.uid == resource.data.to);
    }

    // ============================================================
    // FRIENDS COLLECTION
    // ============================================================

    match /Friends/{friendId} {
      // Read for array-contains queries
      allow read: if isAuth() && request.auth.uid in resource.data.users;
      
      // Create: user must be in users array, validate structure
      allow create: if isAuth() && 
                      request.auth.uid in request.resource.data.users &&
                      request.resource.data.users.size() == 2 &&
                      request.resource.data.streakCount == 0 &&
                      validTimestamp(request.resource.data.createdAt);
      
      // Update: only members can update, protect core fields
      allow update: if isAuth() && 
                      request.auth.uid in resource.data.users &&
                      // Cannot change users array
                      request.resource.data.users == resource.data.users &&
                      // Cannot decrease streakCount arbitrarily (backend handles resets)
                      (request.resource.data.streakCount >= resource.data.streakCount ||
                       request.resource.data.streakCount == 0);
      
      // Delete: either member can unfriend
      allow delete: if isAuth() && request.auth.uid in resource.data.users;
    }

    // ============================================================
    // CHATS COLLECTION
    // ============================================================

    match /Chats/{chatId} {
      // Helper: Check if user's UID is part of the chat ID (format: uid1_uid2 sorted)
      function isUserInChatId() {
        return chatId.matches('.*' + request.auth.uid + '.*');
      }
      
      // Read: member check via chatId pattern or document membership
      allow read: if isAuth() && (
                    (resource != null && request.auth.uid in resource.data.members) ||
                    isUserInChatId()
                  );
      
      // Create: only if user is in the members array
      allow create: if isAuth() && 
                      request.auth.uid in request.resource.data.members &&
                      request.resource.data.members.size() == 2 &&
                      validTimestamp(request.resource.data.createdAt);
      
      // Update: only members can update (lastMessage, etc.)
      allow update: if isAuth() && 
                      request.auth.uid in resource.data.members &&
                      // Cannot change members
                      request.resource.data.members == resource.data.members;

      // Messages subcollection
      match /Messages/{messageId} {
        // Read: chat members only
        allow read: if isAuth() && 
                     request.auth.uid in get(/databases/(default)/documents/Chats/$(chatId)).data.members;
        
        // Create: sender must be auth user and chat member
        allow create: if isAuth() && 
                        request.auth.uid == request.resource.data.sender &&
                        request.auth.uid in get(/databases/(default)/documents/Chats/$(chatId)).data.members &&
                        request.resource.data.type in ['text', 'image'] &&
                        validTimestamp(request.resource.data.createdAt) &&
                        // Content length limits
                        (request.resource.data.type == 'image' || 
                         validStringLength(request.resource.data.content, 1, 2000));
        
        // Update: members can update (mark read, etc.)
        allow update: if isAuth() && 
                        request.auth.uid in get(/databases/(default)/documents/Chats/$(chatId)).data.members &&
                        // Prevent changing sender/content/type
                        request.resource.data.sender == resource.data.sender &&
                        request.resource.data.content == resource.data.content &&
                        request.resource.data.type == resource.data.type;
        
        // Delete: members can delete (view-once snaps)
        allow delete: if isAuth() && 
                        request.auth.uid in get(/databases/(default)/documents/Chats/$(chatId)).data.members;
      }
    }

    // ============================================================
    // STORIES COLLECTION
    // ============================================================

    match /stories/{storyId} {
      // Read: only recipients can view
      allow read: if isAuth() && request.auth.uid in resource.data.recipientIds;
      
      // Create: author validation
      allow create: if isAuth() && 
                      request.auth.uid == request.resource.data.authorId &&
                      validTimestamp(request.resource.data.createdAt) &&
                      // expiresAt must be in future (24h from creation typically)
                      request.resource.data.expiresAt > request.time.toMillis() &&
                      // recipientIds must include author and be reasonable size
                      request.auth.uid in request.resource.data.recipientIds &&
                      validArraySize(request.resource.data.recipientIds, 1000) &&
                      // Initial viewCount must be 0
                      request.resource.data.viewCount == 0;
      
      // Update: author for content, anyone for viewCount increment
      allow update: if isAuth() && (
                      // Author can update anything
                      request.auth.uid == resource.data.authorId ||
                      // Others can only increment viewCount by 1
                      (request.auth.uid in resource.data.recipientIds &&
                       request.resource.data.diff(resource.data).affectedKeys().hasOnly(['viewCount']) &&
                       request.resource.data.viewCount == resource.data.viewCount + 1)
                    );
      
      // Delete: author only
      allow delete: if isAuth() && request.auth.uid == resource.data.authorId;

      // Views subcollection
      match /views/{userId} {
        // User can read their own view record
        allow read: if isAuth() && userId == request.auth.uid;
        
        // User can only write their own view record
        allow create: if isAuth() && 
                        userId == request.auth.uid &&
                        request.resource.data.userId == request.auth.uid &&
                        validTimestamp(request.resource.data.viewedAt);
        
        allow update: if isAuth() && userId == request.auth.uid;
        allow delete: if false; // Views are permanent
      }
    }

    // ============================================================
    // REPORTS COLLECTION
    // ============================================================

    match /Reports/{reportId} {
      // Only reporter can create
      allow create: if isAuth() && 
                      request.auth.uid == request.resource.data.reporterId &&
                      request.resource.data.reporterId != request.resource.data.reportedUserId &&
                      request.resource.data.reason in ['spam', 'harassment', 'inappropriate_content', 'fake_account', 'other'] &&
                      request.resource.data.status == 'pending' &&
                      validTimestamp(request.resource.data.createdAt) &&
                      // Optional description length limit
                      (!request.resource.data.keys().hasAll(['description']) ||
                       validStringLength(request.resource.data.description, 0, 500));
      
      // No read/update/delete from client - admin only via Cloud Functions
      allow read, update, delete: if false;
    }

    // ============================================================
    // GAME SESSIONS COLLECTION
    // ============================================================

    match /GameSessions/{sessionId} {
      // Only player can read their sessions
      allow read: if isAuth() && request.auth.uid == resource.data.playerId;
      
      // Create with validation
      allow create: if isAuth() && 
                      request.auth.uid == request.resource.data.playerId &&
                      request.resource.data.score >= 0 &&
                      validTimestamp(request.resource.data.playedAt);
      
      // Sessions are immutable
      allow update, delete: if false;
    }

    // ============================================================
    // COSMETICS COLLECTION (Read-only, admin seeded)
    // ============================================================

    match /Cosmetics/{itemId} {
      allow read: if isAuth();
      allow write: if false; // Admin only via Firebase Console or Cloud Functions
    }

    // ============================================================
    // CATCH-ALL: Deny everything else
    // ============================================================

    match /{document=**} {
      allow read, write: if false;
    }
  }
}
